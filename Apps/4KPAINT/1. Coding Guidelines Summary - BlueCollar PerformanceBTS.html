# Writing FileMaker™ Database Software  
# Code Development Guidelines, Design Patterns, Development Environment Setup, and Release Management  

**Updated:** 12/8/2025  
**Prepared by:** Kirk Rheinlander  

---

# Executive Overview

This document is a living playbook. It is shaped by years of FileMaker work, wins, mistakes, and the kind of hard lessons that show up only after you maintain a real system under real pressure.

The goal is simple:

- Build faster  
- Ship with fewer errors  
- Leave behind code your future self can understand without pain  

This is guidance for future development. Older code in the product may not match these rules. That is fine. Use this as a direction of travel. Apply it during maintenance and refactors where it makes sense.

This document is organized into clear sections:

- How FileMaker works internally and why it changes design decisions  
- Infrastructure and what matters most in real deployments  
- Naming conventions with rationale  
- Tips, tricks, traps, and design patterns that prevent slow systems and messy code  

---

# All About the FileMaker™ Product

## FileMaker™ Applicability

### Why FileMaker?

FileMaker is a full-stack environment inside one product experience.

In many stacks, you build with separate tools for:
- database
- schema and relationships
- UI
- business logic
- integration glue
- deployment
- server operations
- backups
- security

With FileMaker, those pieces live inside one development world. That single UX boosts speed and reduces friction.

Claris® FileMaker™ was ranked #1 (2021) in low code and workflow automation by Forrester and G2 crowdsourcing. It has been evolving quickly, adding capabilities and performance improvements while keeping legacy features alive so older solutions still run.

FileMaker also carries misconceptions. Some come from old limitations. Some come from bad builds that keep the FileMaker name attached. Most performance pain comes from design decisions, not from FileMaker itself.

---

## Key Unique Value Propositions

**Fully integrated development environment**
- GUI layout editor
- relational database
- relationship modeling (superset of ER modeling)
- scripting with auto-complete
- strong calculation engine
- APIs (Data API, OData)
- integrated Web Viewer with JavaScript and two-way data access
- custom functions
- plugin support

---

## Deployment Options

### Development
- macOS
- Windows

### Client environment
- Windows
- macOS
- iOS (FileMaker Go)

### Server environment
- Windows
- macOS
- Linux
- FileMaker Cloud (AWS)

### Hosting models
- single user: macOS, Windows, iOS
- client-server

### Licensing
- single user
- per-seat client-server
- concurrent user (per connection)
- site license (25+ employees)

---

## 3rd Party Tool Support

- **FMPerception** ($499, $249 annual)  
  Fast analysis of the DDR to find errors, usage locations, and dependencies.

- **FMComparison** (free with FMPerception)  
  Uses XML export to compare versions and identify changes.

- **FMLayoutLens** (free with FMPerception)  
  Copy-paste a layout to get a wireframe view of layout components.

- **OttoFMS / OTTODeploy** (free)  
  Deploy dev updates to production automatically. Includes API tooling.

- **Inspector Pro 9** (free)  
  FMS 25+ only. Similar category. Less effective as a dev tool.

- **BaseElements** ($499)  
  Competitive alternative in the analysis category.

- **FMDumpMigrator**  
  Tool to merge data tables via export to SQL then re-import to FileMaker.

- **ZippyCue**  
  New. Limited information available.

- **DDRParser**  
  Limited current experience. TBD.

- **ChangeTracker**  
  New. Looks comprehensive in marketing. Unknown in practice.

- **XML Export Exploder**  
  Breaks XML exports into manageable chunks.

- **Devin**  
  DevOps tool for FileMaker.

- **ProofGeist Labs ModLog**  
  Web-based change tracking using XML export versions. Data remains local.

- **ProofGeist FMSvg**  
  Web tool that converts SVGs into FileMaker syntax with color states.

- **ProofGeist SimpleQ**  
  Lightweight queuing system in FileMaker for loosely coupled apps. Integrates with OttoFMS for webhooks.

- **ProofKit** (proofkit.dev)  
  Tools for FileMaker-aware JavaScript applications.

- **Dracoventions** and others  
  TBD.

---

## FileMaker™ the Company

As of 2021:
- 24M+ copies sold
- 15 languages
- consistently profitable for 80+ quarters
- 3M+ iOS FileMaker Go users
- 500+ certified developers
- 1400 partner organizations worldwide
- 40 Platinum partners in the US
- 50,000+ members in Claris Community

---

# Development

FileMaker’s time-to-value is historically exceptional. AI-driven environments are improving, yet they still lack depth compared to what FileMaker can do end-to-end when driven by a skilled developer.

A strong FileMaker developer can build a deep business solution in days or weeks. Full-stack work often takes months and multiple specialists.

FileMaker also supports practical continuous delivery concepts:
- **Live development** is possible for most changes.  
  Field schema edits temporarily lock records.  
  Any data-changing work should be done after hours with fresh backups.

- **Offline development** is supported with rapid data migration tools.  
  Best for large changes.

---

# Features

FileMaker supports:
- desktop client-server
- single-user desktop
- cloud hosting
- mobile
- web deployment

Web deployment can be enabled quickly from a FileMaker perspective. UI limitations exist, mostly around layout rendering choices, and can be designed around.

WebDirect often delivers strong performance because server-side execution reduces client data transfer.

---

## FileMaker Database Engine

FileMaker’s proprietary database engine has decades of refinement.

Key characteristics:
- Every object has a unique internal ID, only used once.  
  Renames remain stable because references track IDs internally.

- Foreign keys can be generated automatically when you create related records.  
  This reduces orphan record risk, when implemented properly.

- UI tooling is best-of-class for dense business interfaces.
- Pixel-level placement works even in web deployment.
- Event-driven objects and script triggers are deeply supported.
- Portals support related record lists with dynamic filtering.
- List and sub-summary reporting is directly supported.
- Web Viewer can host web pages and JavaScript widgets with two-way data.

Other major capabilities:
- strong scripting language with auto-complete
- limited SQL support with valid use cases
- custom functions
- granular security with formula-based access control
- encryption at rest (optional)
- encryption in transit (client-server and web)
- JSON support for integration
- Data API and OData
- external database connections via ESS
- AppleScript support on macOS

---

## Data Structure Constraints

- 8 TB per table  
- unlimited tables per file  
- unlimited files per solution  

Scale notes:
- tested to 2,000 users
- up to 10 helper WebDirect servers
- around 500 users per helper server

---

# FileMaker™ Limitations and Traps

- Bad design scales badly. Good design scales hard.
- Legacy patterns often have modern replacements that run faster and read clearer.
- Transactions can be implemented. Some environments require commit-all-or-none.
- Team development tooling remains thin. You must build process around it.
- Many performance issues come from novice design decisions.
- The most common performance killer is **unstored calculations**.
- A huge inter-connected relationship graph creates heavy reevaluation cost.
- Use TOG structure to reduce cascading recalculations.
- No master password exists. A full access user can lock everyone out.  
  Security policy must account for this.
- ExecuteSQL can stall if records are locked. This creates unpredictable runtimes.

---

# Structural FileMaker

## Table Occurrences (TO)

TOs are aliases of base tables, used in the relationship graph. They are structural, not decorative.

In FileMaker, relationships act like queries. When you reference related fields, you are reading filtered data defined by the relationship.

Trap to avoid:
- Massive relationship webs with many TOs connected.  
  Data edits trigger reevaluation across related TOs and unstored calcs.

Recommended approach:
- TOGs plus patterns like Anchor-Buoy.  
  Limit recalculation scope. Improve performance and mental clarity.

---

## Core Concept: Context

Context drives everything. Your layout TO matters. Your script context matters. The same field name in a different TO behaves differently because FileMaker evaluates through context.

Debug helper script (assign to a dev-only button):

**List Fields on Layout (3 lines)**
- Set Variable [ $ListFields ; GetFieldsOnLayout ( Get ( LayoutName ) ) ]
- Set Variable [ $ListFields ; Substitute ( $ListFields ; "," ; "¶" ) ]
- Show Custom Dialog [ $ListFields ]

---

## Relationship Diagram

Relationships filter child records based on match conditions.
- compound relationships supported
- globals can drive dynamic matching
- multi-line joins allow OR style matching via lists in one parent field

Portals display the related set. A related field on a parent layout displays the first related record based on relationship sort.

---

## Layouts

Layouts are screens. Some exist only to switch context for scripts.

Views:
- Form view: one record per screen
- List view: many records from found set
- Table view: spreadsheet-like, minimal control, rarely used for end users

---

## Parts

Layout parts structure the screen or report.
- body
- headers and footers
- title headers
- navigation headers
- sub-summary parts for grouped summaries in sorted lists

FMGo note:
- navigation headers do not scale, so use intentionally.

---

## Data Objects

### Fields
Supported types:
- text, number, date, container
- calculation (stored or unstored)
- summary
- global fields (same value across all records for the user session)

### UI objects
- portals
- buttons and button bars
- tab controls and slide controls

---

## ESS (External SQL Sources)

ESS provides supported ODBC connections to external databases and treats them as part of the FileMaker environment.

| Data Sources | Windows Drivers | macOS Drivers | Linux | ESS requires Actual Technology Adapter 1.5.0 |
| --- | --- | --- | --- | --- |
| Oracle Database 11g R2 | Oracle Client 11g R2 | Actual Technologies Oracle 5.0.8 |  |  |
| Oracle Database 12c R1 | Oracle Client 19.11 | Actual Technologies Oracle 5.0.8 | Oracle client 12.2.0.1.0 |  |
| Oracle Database 12c R2 | Oracle Client 19.11 | Actual Technologies Oracle 5.0.8 | Oracle client 12.2.0.1.0 |  |
| Microsoft SQL Server 2014 to 2017 | SQL Server Native Client 17.5.1.1 | Actual Technologies MS SQL 5.0.8 | MS SQL 17 |  |
| MySQL Community 5.7.21 | MySQL ODBC 8.0 Unicode 8.0.19 | Actual Technologies Open Source DB 5.0.8 | libmyodbc5.so (pre-installed with FMS rpm) |  |
| IBM i 7.3 (AS/400) | iSeries Access ODBC 13.00.01.00 |  |  | X |
| IBM Db2 11.1 | IBM DB2 ODBC 10.05.800.381 |  |  | X |
| PostgreSQL 9.6.12 | PostgreSQL ODBC Unicode 9.03.04.00 | Actual Technologies ODBC Open Source 5.0.8 |  | X |

---

# Security

This section documents security factors supported by FileMaker. It does not map each item point-by-point to FIPS 140-2 or NIST 800 checklists.

FileMaker has provided solution-level authentication and authorization since version 7.

## Privilege Sets and Granular Controls

Security can be formula-driven down to:
- files
- tables
- fields
- operations

## Authentication

Supports:
- individual users
- policy groups

Trap:
- authentication is more rigorous on macOS than Windows.
- Windows password reset tools exist.  
  Encryption at rest closes that gap, while raising privileged access management risk.

## External Authentication (EA)

Use either:
- internal FileMaker accounts, or
- external identity systems

Azure/Active Directory is the practical winner in many deployments because group names map cleanly.

Trap:
- Google or Amazon may require setting up users both externally and inside FileMaker, creating double work.

## Encryption in Transit (SSL)

SSL is baseline security. FMS requires it.
SSL covers:
- FileMaker clients
- WebDirect
- Admin APIs
- Data API

Pain often lives with SSL vendor processes and naming conventions.

## Encryption at Rest (EAR)

EAR prevents use of stolen database files without credentials.

Trap:
- if a full access user disappears with the only credentials, EAR blocks recovery tools.  
  You need a credential management policy.

## Field Level Security

- encryption and obfuscation options exist
- protected field presentation can mask content during entry and display

## File Access Controls

External file access plus additional file access security can control cross-file linking.

## Security Model Notes

Trap:
- powerful and obscure. During debugging, security rules can look like phantom behavior.

Claris has referenced compliance alignment historically, yet certification processes struggle to keep up with rapid feature evolution.

---

# Optimizations and Modernization

## Data Size and Segregation

More records means more work for finds, sorts, portals, and layouts.

Archiving strategy:
- move older or unused data into archive tables or external files
- keep access available through code when needed

Effort:
- varies by usage patterns
- basic archive creation and migration can be hours per table depending on size

---

## Unstored Calculations and Performance

Unstored calcs can be useful. They can also crush performance.

Real example:
- one SQL step took 400+ seconds due to an unstored calc dependency
- switching to stored logic dropped runtime to around 0.1 seconds
- roughly 4,000x improvement

Priority:
- unstored calcs are the first place to look when performance is poor

---

## Refactoring for Performance, Quality, Maintainability

Consistent design patterns raise readability and speed.
Naming conventions alone improve developer output massively.

Refactoring is ongoing. It is a continuous improvement practice.

---

## Navigation Modernization

Menus fail in FMGo and WebDirect.
Move navigation into screen-based UI so every platform works.

A scrollable menu window approach can be reused for:
- navigation
- field selection
- pick lists

---

## UI Refactoring for Speed and UX

Slow layouts feel broken even when the system is working.

Pattern improvements:
- show a loading overlay
- hide heavy unstored fields until needed
- use intermediary layouts or views that load fast
- reduce cognitive load with performer-centric UI design

Effort:
- can be significant for dense legacy layouts
- do triage first, then refactor in waves

---

## UUID vs Serialized Keys

Serialized keys collide across databases. Data consolidation becomes risky.

UUIDs are globally unique with extremely low collision probability.

Legacy conversion is hard:
- you must update parents and all children to preserve referential integrity

Rule:
- user data must never be relationship keys for core relationships
- use system keys for relationships
- use natural keys for UI only

---

# Performance Design Patterns

## Find Refactor Pattern

Legacy:
- Perform Find [ Restore ] hides logic in a dialog

Modern:
- Enter Find Mode
- Set Field ( field ; value )
- Perform Find

The win:
- visibility
- faster debugging
- fewer hidden mistakes

---

## Layout Switch Performance Pattern

Problem:
- layout loads all records first, then you constrain

Fix:
- enter find mode before switching to presentation layout
- perform a find that returns minimal records

Example approach:
- set pk to "=" to return empty set
- perform find
- then show layout with minimal load

---

## Loop Refactor Pattern for Finds

Legacy:
- loop
- find each item one by one
- N finds means N full traversals

Refactor:
- build multi-request find
- perform one find

Result:
- N items becomes one traversal

---

## Fields Pattern

Unstored calcs:
- avoid heavy use
- avoid in list views
- prefer stored patterns or scripted updates where feasible

Landing screen:
- use a global table splash layout to show something fast

Always restrict initial data display:
- never load every invoice on entry
- load the subset relevant to the workflow

---

## Portal Filters Pattern

Trap:
- portal filters apply after load. Large sets load first, then filter. Slow.

Tip:
- filter via relationship first
- portal filter only as secondary refinement

---

## TOGs and Relationship Graph Hygiene

Trap:
- too many relationships trigger too many recalculations
- connector-heavy patterns reduce TOG independence

Use TOGs to:
- contain recalculation scope
- improve performance and maintainability

---

## Summary ListOf Pattern

ListOf summary (FM14+) returns a field list for the found set very fast.

Use case:
- build ID lists for relationship matching
- support cross-TOG found set reuse

---

## RecordID Pattern Across TOGs

RecordID is in memory and can be extremely fast to list.

Approach:
- store RecordID in a stored field
- also have an unstored RecordID calc
- ListOf summary on unstored RecordID returns fast
- write list into a global match field
- relate to stored RecordID and GTRR into the set

Critical note:
- RecordID is not a UUID replacement
- copying files and removing data can rebuild RecordIDs
- treat RecordID as transactional, not permanent identity

---

## Insert Calc Result vs Set Variable

Set Variable with concatenation grows slower as the variable grows.

Insert Calculated Result stays more consistent as the list grows.

For large record sets, Insert Calculated Result often wins.

---

## Related Table Finds Trap

Finding on a related field can return parents based on any matching child record, even when the UI shows only the first related record.

This creates confusing results.

Workarounds exist, including multi-step GTRR patterns.

---

## Get (FoundCount) Pattern

Unstored Get (FoundCount) in a child context can show counts on parent layouts through relationships.

Trap:
- portal filter does not change found set count  
  Another reason to prefer relationship filtering.

---

## Portal Record Add Pattern

Use a one-row portal with a filter set to false.
- relationship allows create through
- entering data creates the child record
- the record appears in the main portal immediately

Clean UI tip:
- hide row objects when pk is empty
- sort portal so newest appears at top

---

# Hardware

Hardware matters. Bad design still loses.

Priority factors:
- network performance affects thick client models
- Disk IOPS drives database responsiveness
- SSD and NVMe greatly improve throughput
- RAID can improve performance and resilience
- more CPU cores and stronger clocks improve server work

Best practice:
- NVMe SSDs with RAID for FileMaker Server workloads

---

# Data API, OData, and Alternative Clients

FileMaker Data API enables scalable integration and alternative client experiences.

Advantage:
- Data API can support many users without consuming FileMaker user licenses in the same way a thick client does.

## Tools and options

### FMBetterForms
JavaScript widgets and JSON structures interacting with FileMaker.

### WebDirect
Fast deployment, high fidelity, server-side execution. Often excellent performance.

### Terminal Server
Similar benefit to WebDirect. Heavy on resources.

### Web Viewer
Embed web pages and JavaScript libraries. Two-way data sharing enables rich widgets and inputs.

---

# Development Process

## SDLC and Release Management

Lightweight process, serious results:
- root cause analysis
- debug
- unit test
- code review
- system test
- production release
- resolution description and checklist

## Performing Reviews

Legacy knowledge matters. Code review is also knowledge transfer.

Rules of thumb:
- most reviews under 5 minutes
- screen share works well
- keep WIP copies in a dedicated folder
- move changes into a review folder before release

## Prioritization by Severity

- Sev4: can release without review
- Sev3: quick review
- Sev1 and Sev2: strict review and testing

Data-impacting changes:
- test on non-production data or have rollback plan

Maintain a checklist for impacts:
- scripts, TOs, fields, calcs, layouts, UI objects

---

## Bug Tracking

Move away from unstructured email reports.

A strong bug report captures automatically:
- user and account
- IP and NIC
- OS version
- FileMaker version
- server
- privilege set
- file name
- layout name
- table occurrence context
- solution instance
- timestamp
- default severity

Most important:
- a snapshot link that takes the developer directly to the user’s exact context and found set.

---

# Naming Conventions

Naming conventions buy speed, clarity, and fewer mistakes.
They also make patterns reusable across the system.

Areas impacted:
- tables
- fields
- TOs
- scripts
- variables
- layouts
- value lists
- folders
- script comments and structure

## Code Notations

Use consistent comment markers for fast DDR searching and review:

- `# #################################` Comment Block  
- `# ---------------------------------` Sub-functional break  
- `# =================================` Major change break  
- `# xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx` End of code  
- `# ?????????????????????????????????` Code review question  
- `# *********************************` Alternative approach  
- `# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!` Concern  
- `# TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT` Test code  

### Script Header Block Standard

Each script should start with a consistent block:

```

#

# Performs: <functional abstract description>

# Created on: <date created>

# Created by: <developer name>

# Last Modified: <date modified>

# Modified by: <developer name>

#

# <Change description>

# <Change description>

#

```

---

## Cardinal Naming Rules

- No spaces in names
- No leading punctuation or special characters
- Pick a technique and stick with it (CamelCase or underscores_as_spaces)
- Decide singular vs plural and stay consistent

---

## Tables

### Source tables
- All UPPER CASE
- prefix with `z_`  
  Example: `z_CLIENT`

Tip:
- pushes base tables to bottom of selection lists
- visually distinguishes source tables from TO aliases

Rule:
- source tables should not be used directly on layouts, scripts, or calcs  
  Exception: context-independent SQL usage

---

## Table Occurrences (TO)

TO names must show relationship meaning.

Recommended structure:
- parent to child naming reads left to right
- source table name in UPPER CASE
- include relationship term with tildes  
  Example: `parent~id~CHILD|sDatePaid`

Also use a prefix:
- first char: group type, like T or U
- next two digits: group number
- last char: hierarchy level a, b, c
- underscore, then TO name

Example:
- `T01a_INVENTORY`
- `T01b_inventory~ID~SKUS`

---

## Table Occurrence Groups (TOG)

Recommended groupings:
- core data TOG for base relationships
- presentation TOG for view model
- edit and reporting TOGs
- selection TOGs for GTRR patterns

---

## Field Names

Three groups:
- key fields (`a__`)
- user data fields (no prefix)
- utility fields (`z*`)

Utility prefixes:
- `z_` utility
- `za_` auto-enter
- `zc_` calculation
- `zgm_` global match field
- `zk_` constant
- `zs_` summary
- `zsl_` summary list
- `zu_` utility (rare)
- `zx_` deprecated

Globals:
- store in a globals table where possible
- prefix with `g_`
- exception: globals used for relationship matching may live in data tables with `zgm_` or `zgk_`

---

## Key Fields

### Primary key
- name: `a__pkid` or `a__pk` in every table  
  Consistency enables modular code.

### Foreign key
- format: `a__fkid_CHILD`

Trick:
- create through relationship auto-fills foreign keys.

Trap:
- phantom portal row behavior when create through is enabled  
  Use ghost portal patterns to manage UX.

Rule:
- foreign keys are effectively immutable  
  dynamic foreign key changes are a design smell

---

## Data Fields

Use clear human names suitable for labels.

Group fields by general-to-specific naming:
- `Date_paid`
- `Date_invoiced`
- `Date_shipped`

---

## Stored vs Unstored Calculations

Unstored calcs:
- powerful for UI logic and dynamic behaviors
- dangerous for performance in lists and portals

Key traps:
- list views force evaluation across many records
- unstored calcs cannot be indexed
- finds against unstored calcs are expensive

Safe usage:
- form views
- conditional formatting and hide logic
- summary fields where worth the cost

Modern replacement patterns:
- scripted updates
- auto-enter where appropriate
- trigger-driven denormalization

---

## Validation and UX

Trap:
- post-entry validation nagware feels bad and confuses users.

Better:
- constrain input at entry time
- value lists and UI pickers
- code-based validation with clear messages
- return a list of problems, not one vague error

---

# Layout Naming

Use layout names users recognize.
This enables:
- simple navigation by name
- value list driven layout navigation
- fewer hard-coded mappings

Indirection tip:
- GetLayoutNames and GetLayoutIDs return parallel lists
- use LayoutID navigation to reduce brittleness

Utility layouts:
- add a clear prefix so they do not appear in user navigation

Blank layouts:
- fast context switching
- execute finds, sorts, updates without heavy UI load

---

# Scripts

Script naming:
- action-object (verb-noun)
- include parameter intent when relevant

Folder structure:
- group by TOG
- separate navigation, shared code, UI, business logic

---

# Presentation and Styles

Styles load fast and keep layout rendering efficient.

Trap:
- manual formatting overrides produce CSS bloat and performance drag.

Theme notes:
- old pre-14 themes render poorly in WebDirect
- changing a style changes everything that uses it

Style naming preference:
- format-based names, not function-based names  
  Example: `18ptBld_LJ_noBG_noLN`

---

# Button Bars

Rule:
- use button bars everywhere, even for one button.

Why:
- flexible labels
- icons
- popovers
- data display
- dynamic menus
- dashboards

Traps and tricks:
- hiding segments changes widths, looks ugly  
  Add an opposite-hide segment to keep segment count constant.
- capturing clicked label can be tricky  
  Conditional formatting trick: `Let ( $$Name = Self ; 1 )`
- active state blocks double click in some patterns  
  Set active calculation to a value that never matches.

---

# Web Viewer and Containers

Traps:
- popovers will not open over web viewers
- on Windows, popovers will not open over container fields

Workaround:
- hide the web viewer or container during popover open and restore after

PDF notes:
- rendering varies by PDF
- provide multiple viewing modes
- FileMaker 19.3 uses Edge PDF engine on Windows

---

# WebDirect Notes

WebDirect works well and performs strongly with adequate server resources.

Trap:
- value list editing inside value list controls is not available in WebDirect.

---

# Code Deployment

Managing dev versus prod requires discipline and tooling.
OTTOFMS and OTTODeploy are key enablers for clean release flow.

---

# The End

**Version:** Revision R9  
**Last Edit Date:** 12/8/2025  
**Prepared by:** Kirk Rheinlander
```